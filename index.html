<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>Teilchenmodell – Temperatur 8°C → 23°C</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    /* Breite/Höhe des Quadrats + Höhe der Kopfzeile */
    :root {
      --sim-size: 1080px;       /* Quadratische Simulationsfläche */
      --header-height: 1.2cm;   /* Sichtbarer Kopfbereich für Temperatur */
    }

    body {
      margin: 0;
      background: #fff;
      color: #000;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    /* Gesamtfläche: Kopf + Quadrat */
    .stage {
      width: var(--sim-size);
      height: calc(var(--sim-size) + var(--header-height));
      margin: 24px auto;
      display: flex;
      flex-direction: column;
      background: #fff;
    }

    /* Kopfzeile: Temperatur sichtbar, rechtsbündig, ohne Hintergrund */
    .header {
      position: relative;
      height: var(--header-height);
      display: flex;
      align-items: center;
      justify-content: flex-end;   /* rechtsbündig */
      padding-right: 8px;          /* kleiner Rand rechts */
    }
    .temp {
      font-size: 16px;
      line-height: 1;
      white-space: nowrap;
      user-select: none;
      pointer-events: none;
      color: #000;
    }

    /* Quadratischer Simulationsbereich */
    .sim-wrap {
      width: var(--sim-size);
      height: var(--sim-size);
      background: #fff;            /* weißer Hintergrund */
      position: relative;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: #fff;
    }

    /* Responsiv: Quadrat wird kleiner, Kopf bleibt sichtbar */
    @media (max-width: 1200px) {
      :root { --sim-size: min(90vw, 1080px); }
    }
  </style>
</head>
<body>
  <div class="stage" id="stageRoot">
    <div class="header">
      <div class="temp" id="tempText">Temperatur: 8.0 °C</div>
    </div>

    <div class="sim-wrap" id="simWrap">
      <canvas id="sim" aria-label="Teilchenmodell"></canvas>
    </div>
  </div>

  <script>
    // ===== Parameter =====
    const N = 30;                          // Anzahl Partikel
    const DURATION_S = 60;                  // Temperaturanstieg über 60 s
    const START_C = 8.0, END_C = 23.0;      // °C
    const START_K = START_C + 273.15, END_K = END_C + 273.15;
    const BASE_SPEED = 0.42;                // Grundgeschwindigkeit
    const PARTICLE_RADIUS = 0.018;          // in Box-Einheiten (Box = 1×1)
    const SETTLE_TIME = 1.0;                // ~1 s nahezu stiller Start
    const MIN_START_SCALE = 0.02;           // kleines Anfangszucken
    const DT = 0.005;                       // Simulations-Substep
    const COLOR = "#ff6aa2";                // rosa
    const BOX_SIZE = 1.0;                   // Koordinaten 0..1

    // ===== DOM-Referenzen =====
    const canvas = document.getElementById("sim");
    const tempEl = document.getElementById("tempText");
    const simWrap = document.getElementById("simWrap");
    const ctx = canvas.getContext("2d");

    // ===== Canvas passend zum quadratischen Simulationsbereich skalieren =====
    function resizeCanvas() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const w = simWrap.clientWidth;
      const h = simWrap.clientHeight; // Quadrat
      canvas.width = Math.round(w * dpr);
      canvas.height = Math.round(h * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // Zeichnen in CSS-Pixeln
    }
    resizeCanvas();
    window.addEventListener("resize", resizeCanvas, { passive: true });

    // ===== Utility =====
    const rand = (a,b) => a + Math.random() * (b - a);
    const clamp = (x,a,b) => (x < a ? a : (x > b ? b : x));

    // ===== Zustand =====
    const pos = new Array(N);
    const vel = new Array(N);

    // Nicht-überlappende Startpositionen
    function initPositions() {
      const r = PARTICLE_RADIUS;
      for (let i = 0; i < N; i++) {
        let ok = false;
        for (let t = 0; t < 30000; t++) {
          const x = rand(r, BOX_SIZE - r);
          const y = rand(r, BOX_SIZE - r);
          let valid = true;
          for (let j = 0; j < i; j++) {
            const dx = x - pos[j].x, dy = y - pos[j].y;
            if (Math.hypot(dx, dy) < 2 * r * 1.12) { valid = false; break; }
          }
          if (valid) { pos[i] = { x, y }; ok = true; break; }
        }
        if (!ok) throw new Error("Konnte Partikel nicht überlappungsfrei platzieren.");
      }
    }

    function initVelocities() {
      for (let i = 0; i < N; i++) {
        const a = Math.random() * 2 * Math.PI;
        vel[i] = { x: Math.cos(a) * BASE_SPEED, y: Math.sin(a) * BASE_SPEED };
      }
    }

    initPositions();
    initVelocities();

    // ===== Temperatur in Kelvin (linearer Anstieg über 60 s) =====
    function temperatureK(t) {
      const a = clamp(t / DURATION_S, 0, 1);
      return START_K * (1 - a) + END_K * a;
    }

    // ===== Kollisionen =====
    function resolveWalls(i) {
      const r = PARTICLE_RADIUS, p = pos[i], v = vel[i];
      if (p.x - r < 0) { p.x = r; v.x = Math.abs(v.x); }
      else if (p.x + r > BOX_SIZE) { p.x = BOX_SIZE - r; v.x = -Math.abs(v.x); }
      if (p.y - r < 0) { p.y = r; v.y = Math.abs(v.y); }
      else if (p.y + r > BOX_SIZE) { p.y = BOX_SIZE - r; v.y = -Math.abs(v.y); }
    }

    function resolvePairs() {
      const r = PARTICLE_RADIUS, minDist = 2 * r;
      for (let i = 0; i < N; i++) {
        for (let j = i + 1; j < N; j++) {
          const dx = pos[j].x - pos[i].x;
          const dy = pos[j].y - pos[i].y;
          const dist = Math.hypot(dx, dy);
          if (dist < minDist) {
            // Normale
            let nx, ny;
            if (dist === 0) {
              const a = Math.random() * 2 * Math.PI; nx = Math.cos(a); ny = Math.sin(a);
            } else {
              nx = dx / dist; ny = dy / dist;
            }
            const overlap = minDist - dist;
            // Trennen
            pos[i].x -= nx * (overlap / 2); pos[i].y -= ny * (overlap / 2);
            pos[j].x += nx * (overlap / 2); pos[j].y += ny * (overlap / 2);
            // Elastischer Stoß (gleiche Massen)
            const dvx = vel[i].x - vel[j].x;
            const dvy = vel[i].y - vel[j].y;
            const vn = dvx * nx + dvy * ny;
            if (vn <= 0) {
              vel[i].x -= vn * nx; vel[i].y -= vn * ny;
              vel[j].x += vn * nx; vel[j].y += vn * ny;
            }
          }
        }
      }
    }

    // ===== Simulation / Zeichnen =====
    let startTime = performance.now();

    function step(now) {
      const elapsed = (now - startTime) / 1000; // s
      const T = temperatureK(elapsed);
      const scaleT = Math.sqrt(T / START_K);

      // Sanfter Anlauf (erste ~1 s)
      const settle = (elapsed < SETTLE_TIME)
        ? (MIN_START_SCALE + (1 - MIN_START_SCALE) * (elapsed / SETTLE_TIME))
        : 1.0;

      const scale = scaleT * settle;

      // Feste Substeps
      let remaining = Math.min(1 / 30, 0.05);
      while (remaining > 0) {
        const dt = Math.min(DT, remaining);

        // Geschwindigkeiten auf BASE_SPEED*scale normieren (Richtung beibehalten)
        for (let i = 0; i < N; i++) {
          const v = vel[i];
          const mag = Math.hypot(v.x, v.y) || 1e-9;
          const target = BASE_SPEED * scale;
          v.x = (v.x / mag) * target;
          v.y = (v.y / mag) * target;
        }

        // Position + Wände
        for (let i = 0; i < N; i++) {
          pos[i].x += vel[i].x * dt;
          pos[i].y += vel[i].y * dt;
          resolveWalls(i);
        }

        // Paar-Kollisionen (zwei Durchläufe stabilisieren)
        resolvePairs();
        resolvePairs();

        remaining -= dt;
      }

      // Zeichnen im Quadrat
      const w = canvas.clientWidth, h = canvas.clientHeight;
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = "#fff";
      ctx.fillRect(0, 0, w, h);

      // Box(0..1) -> Pixel
      ctx.save();
      ctx.scale(w, h);
      ctx.fillStyle = COLOR;
      for (let i = 0; i < N; i++) {
        const p = pos[i];
        ctx.beginPath();
        ctx.arc(p.x, p.y, PARTICLE_RADIUS, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();

      // Temperatur-Text aktualisieren (eine Nachkommastelle)
      tempEl.textContent = `Temperatur: ${(T - 273.15).toFixed(1)} °C`;

      requestAnimationFrame(step);
    }

    requestAnimationFrame(step);
  </script>
</body>
</html>
