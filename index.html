<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>Teilchenmodell – Temperatur 8°C → 23°C</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --sim-size: 1080px;     /* Quadratgröße */
      --header-height: 1.2cm; /* sichtbare Kopfzeile */
    }

    body {
      margin: 0;
      background: #fff;
      color: #000;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    /* Gesamtfläche: Kopf + Quadrat */
    .stage {
      position: relative; /* für die Overlays unten rechts */
      width: var(--sim-size);
      height: calc(var(--sim-size) + var(--header-height));
      margin: 24px auto;
      display: flex;
      flex-direction: column;
      background: #fff;
    }

    /* Kopfzeile mit Temperatur + Reset */
    .header {
      height: var(--header-height);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 12px;
    }
    .temp {
      font-size: 16px;
      white-space: nowrap;
      user-select: none;
      pointer-events: none;
    }
    button.reset {
      font-size: 14px;
      background: #eee;
      border: 1px solid #ccc;
      border-radius: 6px;
      padding: 4px 10px;
      cursor: pointer;
      transition: background 0.2s;
    }
    button.reset:hover { background: #ddd; }

    /* Quadratischer Simulationsbereich */
    .sim-wrap {
      width: var(--sim-size);
      height: var(--sim-size);
      background: #fff;
      position: relative;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: #fff;
    }

    /* Panel unten rechts: Kollisionsraten-Tabelle (Option 6-Stil) */
    .rate-panel {
      position: absolute;
      right: 12px;
      bottom: 10px;
      background: rgba(255,255,255,0.9);
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 8px 10px;
      font-size: 14px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
    }
    .rate-panel table {
      border-collapse: collapse;
    }
    .rate-panel th,
    .rate-panel td {
      padding: 2px 6px;
      border-bottom: 1px solid #eee;
      text-align: right;
      white-space: nowrap;
    }
    .rate-panel th:first-child,
    .rate-panel td:first-child {
      text-align: left;
    }
    .rate-panel tr:last-child th,
    .rate-panel tr:last-child td {
      border-bottom: none;
    }
    .muted { color: #666; }

    /* Responsiv */
    @media (max-width: 1200px) {
      :root { --sim-size: min(90vw, 1080px); }
    }
  </style>
</head>
<body>
  <div class="stage" id="stageRoot">
    <div class="header">
      <div class="temp" id="tempText">Temperatur: 8.0 °C</div>
      <button class="reset" id="resetBtn">Reset</button>
    </div>

    <div class="sim-wrap" id="simWrap">
      <canvas id="sim" aria-label="Teilchenmodell"></canvas>

      <!-- Kollisionsraten-Panel (unten rechts) -->
      <div class="rate-panel">
        <table>
          <thead>
            <tr><th>Temperatur</th><th>Kollisionsrate / s</th></tr>
          </thead>
          <tbody>
            <tr><td>8&nbsp;°C</td><td id="rate8"  class="muted">–</td></tr>
            <tr><td>13&nbsp;°C</td><td id="rate13" class="muted">–</td></tr>
            <tr><td>18&nbsp;°C</td><td id="rate18" class="muted">–</td></tr>
            <tr><td>23&nbsp;°C</td><td id="rate23" class="muted">–</td></tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <script>
    // ===== Parameter =====
    const N = 30;
    const DURATION_S = 60;                    // 8 °C → 23 °C linear in 60 s
    const START_C = 8.0, END_C = 23.0;
    const START_K = START_C + 273.15, END_K = END_C + 273.15;
    const BASE_SPEED = 0.42;
    const PARTICLE_RADIUS = 0.018;            // Box = 1×1
    const SETTLE_TIME = 1.0;
    const MIN_START_SCALE = 0.02;
    const DT = 0.005;
    const COLOR = "#ff6aa2";
    const BOX_SIZE = 1.0;

    // Ziel-Sekunden für die vier Temperatur-Schritte (T = 8 + 0.25 t  →  t = 4*(T-8))
    const TARGET_SECONDS = { "8": 1, "13": 20, "18": 40, "23": 60 };
    // Erklärung:
    // 8°C → wir nehmen das erste volle Sek.-Fenster [0..1] → Sekunde 1
    // 13°C → t=20 s → Fenster [19..20] → Sekunde 20
    // 18°C → t=40 s → Fenster [39..40] → Sekunde 40
    // 23°C → t=60 s → Fenster [59..60] → Sekunde 60

    // ===== DOM =====
    const canvas = document.getElementById("sim");
    const tempEl = document.getElementById("tempText");
    const resetBtn = document.getElementById("resetBtn");
    const simWrap = document.getElementById("simWrap");
    const rate8El  = document.getElementById("rate8");
    const rate13El = document.getElementById("rate13");
    const rate18El = document.getElementById("rate18");
    const rate23El = document.getElementById("rate23");
    const ctx = canvas.getContext("2d");

    function resizeCanvas() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const w = simWrap.clientWidth;
      const h = simWrap.clientHeight;
      canvas.width = Math.round(w * dpr);
      canvas.height = Math.round(h * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    resizeCanvas();
    window.addEventListener("resize", resizeCanvas, { passive: true });

    // ===== Zustand =====
    let pos, vel, startTime;
    let totalCollisions = 0;

    // pro-Sekunde-Kumulativwerte: totals[sec] = totalCollisions am Ende dieser Sekunde
    let totalsBySecond = [];
    let lastWholeSecond = -1;

    const rand = (a,b)=>a + Math.random()*(b-a);
    const clamp=(x,a,b)=>x<a?a:(x>b?b:x);

    function initPositions() {
      pos = new Array(N);
      const r = PARTICLE_RADIUS;
      for (let i = 0; i < N; i++) {
        let ok = false;
        for (let t = 0; t < 30000; t++) {
          const x = rand(r, BOX_SIZE - r);
          const y = rand(r, BOX_SIZE - r);
          let valid = true;
          for (let j = 0; j < i; j++) {
            const dx = x - pos[j].x, dy = y - pos[j].y;
            if (Math.hypot(dx, dy) < 2 * r * 1.12) { valid = false; break; }
          }
          if (valid) { pos[i] = { x, y }; ok = true; break; }
        }
        if (!ok) throw new Error("Konnte Partikel nicht überlappungsfrei platzieren.");
      }
    }

    function initVelocities() {
      vel = new Array(N);
      for (let i = 0; i < N; i++) {
        const a = Math.random() * 2 * Math.PI;
        vel[i] = { x: Math.cos(a) * BASE_SPEED, y: Math.sin(a) * BASE_SPEED };
      }
    }

    function temperatureK(t) {
      const a = clamp(t / DURATION_S, 0, 1);
      return START_K * (1 - a) + END_K * a;
    }

    function resolveWalls(i) {
      const r = PARTICLE_RADIUS, p = pos[i], v = vel[i];
      if (p.x - r < 0) { p.x = r; v.x = Math.abs(v.x); }
      else if (p.x + r > BOX_SIZE) { p.x = BOX_SIZE - r; v.x = -Math.abs(v.x); }
      if (p.y - r < 0) { p.y = r; v.y = Math.abs(v.y); }
      else if (p.y + r > BOX_SIZE) { p.y = BOX_SIZE - r; v.y = -Math.abs(v.y); }
    }

    // gibt Anzahl Partikel-Partikel-Kollisionen in diesem Durchlauf zurück
    function resolvePairs(countCollisions = true) {
      const r = PARTICLE_RADIUS, minDist = 2 * r;
      let counted = 0;
      for (let i = 0; i < N; i++) {
        for (let j = i + 1; j < N; j++) {
          const dx = pos[j].x - pos[i].x;
          const dy = pos[j].y - pos[i].y;
          const dist = Math.hypot(dx, dy);
          if (dist < minDist) {
            let nx, ny;
            if (dist === 0) {
              const a = Math.random() * 2 * Math.PI; nx = Math.cos(a); ny = Math.sin(a);
            } else {
              nx = dx / dist; ny = dy / dist;
            }
            const overlap = minDist - dist;
            pos[i].x -= nx * (overlap / 2); pos[i].y -= ny * (overlap / 2);
            pos[j].x += nx * (overlap / 2); pos[j].y += ny * (overlap / 2);

            const dvx = vel[i].x - vel[j].x;
            const dvy = vel[i].y - vel[j].y;
            const vn = dvx * nx + dvy * ny;
            if (vn <= 0) {
              vel[i].x -= vn * nx; vel[i].y -= vn * ny;
              vel[j].x += vn * nx; vel[j].y += vn * ny;
              if (countCollisions) counted++;
            }
          }
        }
      }
      return counted;
    }

    function updateRatesTableIfReady(sec) {
      // Falls wir den kumulativen Stand für diese Sekunde haben, trage die Rate ein.
      // Rate in Sekunde s ist totals[s] - totals[s-1].
      function setRate(temp, secIndex, el){
        if (totalsBySecond[secIndex] != null && totalsBySecond[secIndex-1] != null) {
          const rate = totalsBySecond[secIndex] - totalsBySecond[secIndex-1];
          el.textContent = String(rate);
          el.classList.remove("muted");
        }
      }
      if (sec >= TARGET_SECONDS["8"])  setRate(8,  TARGET_SECONDS["8"],  rate8El);
      if (sec >= TARGET_SECONDS["13"]) setRate(13, TARGET_SECONDS["13"], rate13El);
      if (sec >= TARGET_SECONDS["18"]) setRate(18, TARGET_SECONDS["18"], rate18El);
      if (sec >= TARGET_SECONDS["23"]) setRate(23, TARGET_SECONDS["23"], rate23El);
    }

    function resetRatesTable() {
      rate8El.textContent = "–";  rate8El.classList.add("muted");
      rate13El.textContent = "–"; rate13El.classList.add("muted");
      rate18El.textContent = "–"; rate18El.classList.add("muted");
      rate23El.textContent = "–"; rate23El.classList.add("muted");
    }

    function resetSimulation() {
      initPositions();
      initVelocities();
      startTime = performance.now();
      totalCollisions = 0;
      totalsBySecond = [];
      lastWholeSecond = -1;
      tempEl.textContent = "Temperatur: 8.0 °C";
      resetRatesTable();
    }

    function step(now) {
      const elapsed = (now - startTime) / 1000; // s
      const T = temperatureK(elapsed);
      const scaleT = Math.sqrt(T / START_K);
      const settle = (elapsed < SETTLE_TIME)
        ? (MIN_START_SCALE + (1 - MIN_START_SCALE) * (elapsed / SETTLE_TIME))
        : 1.0;
      const scale = scaleT * settle;

      // Physik-Substeps
      let remaining = Math.min(1 / 30, 0.05);
      while (remaining > 0) {
        const dt = Math.min(DT, remaining);
        // Geschwindigkeit normieren
        for (let i = 0; i < N; i++) {
          const v = vel[i];
          const mag = Math.hypot(v.x, v.y) || 1e-9;
          const target = BASE_SPEED * scale;
          v.x = (v.x / mag) * target;
          v.y = (v.y / mag) * target;
        }
        // Bewegung + Wände
        for (let i = 0; i < N; i++) {
          pos[i].x += vel[i].x * dt;
          pos[i].y += vel[i].y * dt;
          resolveWalls(i);
        }
        // Partikel-Partikel-Kollisionen: erster Pass zählt, zweiter stabilisiert
        totalCollisions += resolvePairs(true);
        resolvePairs(false);
        remaining -= dt;
      }

      // pro-Sekunde-Erfassung
      const currentSec = Math.floor(elapsed);
      if (currentSec !== lastWholeSecond) {
        // Kumulativstand am Ende der "letzten" Sekunde ablegen
        totalsBySecond[currentSec] = totalCollisions;
        lastWholeSecond = currentSec;
        // Prüfen, ob Zielsekunden erreicht → Tabelle aktualisieren
        updateRatesTableIfReady(currentSec);
      }

      // Zeichnen
      const w = canvas.clientWidth, h = canvas.clientHeight;
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = "#fff";
      ctx.fillRect(0, 0, w, h);
      ctx.save();
      ctx.scale(w, h);
      ctx.fillStyle = COLOR;
      for (let i = 0; i < N; i++) {
        const p = pos[i];
        ctx.beginPath();
        ctx.arc(p.x, p.y, PARTICLE_RADIUS, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();

      tempEl.textContent = `Temperatur: ${(T - 273.15).toFixed(1)} °C`;
      requestAnimationFrame(step);
    }

    // Start
    resetSimulation();
    requestAnimationFrame(step);

    // Reset-Button
    resetBtn.addEventListener("click", resetSimulation);
  </script>
</body>
</html>
